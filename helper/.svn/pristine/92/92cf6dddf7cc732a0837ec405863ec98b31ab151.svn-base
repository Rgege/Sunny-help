package org.blue.helper.StringHelper.service.impl;

import org.blue.helper.StringHelper.common.exception.HelperException;
import org.blue.helper.StringHelper.service.FileService;
import org.blue.helper.StringHelper.utils.NumberUtils;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static org.apache.commons.lang3.StringUtils.leftPad;

/**
 * @Description <P></P>
 * @Author v-Rui.Xiong@bl.com
 * @Date 2018/12/28
 * @Version 1.0.0
 **/
@Service
public class FileServiceImpl implements FileService {

    @Override
    public void uploadFile(String saveUrl, double fileSize, MultipartFile file) {
        //先创建一个临时文件
        File tmpFile=new File(saveUrl+".tmp");
        if (tmpFile.exists()){
            throw new HelperException(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>Flie:"+saveUrl+" already existed");
        }else {
            try {
                tmpFile.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
                throw new HelperException(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>Failed to create temporary file:"+saveUrl+".tmp",e);
            }
        }

        //通过file size 确定要几个线程
        final double m=1024d;
        int threadNum;
        double mbs=fileSize/m;
        if (NumberUtils.lessOrEqD(mbs,100)){//100M以内单线程模式
            threadNum=1;
        }else if (NumberUtils.leftOpenInterval(100,mbs,500)){//500M 5个线程
            threadNum=5;
        }else if (NumberUtils.leftOpenInterval(500,mbs,1000)){//1G 10个线程
            threadNum=10;
        }else if (NumberUtils.bigD(mbs,1000)){//最多开15个线程
            threadNum=15;
        }

        //将文件分块写入到临时文件中
        //所有的都写完了后再将临时文件的.tmp后缀去掉
    }

    /**
     * 拆分文件
     * @param fileName 待拆分的完整文件名
     * @param byteSize 按多少字节大小拆分
     * @return 拆分后的文件名列表
     * @throws IOException
     */
    public List<String> splitBySize(String fileName, int byteSize)
            throws IOException {
        List<String> parts = new ArrayList<String>();
        File file = new File(fileName);
        int count = (int) Math.ceil(file.length() / (double) byteSize);
        int countLen = (count + "").length();
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(count,
                count * 3, 1, TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(count * 2));

        for (int i = 0; i < count; i++) {
            String partFileName = file.getName() + "."
                    + leftPad((i + 1) + "", countLen, '0') + ".part";
            threadPool.execute(new SplitRunnable(byteSize, i * byteSize,
                    partFileName, file));
            parts.add(partFileName);
        }
        return parts;
    }

    private class SplitRunnable implements Runnable {
        int byteSize;
        String partFileName;
        File originFile;
        int startPos;

        public SplitRunnable(int byteSize, int startPos, String partFileName,
                             File originFile) {
            this.startPos = startPos;
            this.byteSize = byteSize;
            this.partFileName = partFileName;
            this.originFile = originFile;
        }

        public void run() {
            RandomAccessFile rFile;
            OutputStream os;
            try {
                rFile = new RandomAccessFile(originFile, "r");
                byte[] b = new byte[byteSize];
                rFile.seek(startPos);// 移动指针到每“段”开头
                int s = rFile.read(b);
                os = new FileOutputStream(partFileName);
                os.write(b, 0, s);
                os.flush();
                os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
